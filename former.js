// ES5 version of https://github.com/palkan/formerjs
// Generated by ChatGPT-4 (Copilot Chat failed to generate this file)
// UPD: and fixed by me.
(function () {
  "use strict";

  function FormerJS(nod, options) {
    this.nod = nod;
    this.options = options || {};
    this.options.name_transform = this._rails_name_transform.bind(this);
    this.options.parse_value = this._serialize.bind(this);
  }

  FormerJS.parse = function (nod, options) {
    return new FormerJS(nod, options).parse();
  };

  FormerJS.fill = function (nod, options, data) {
    return new FormerJS(nod, options).fill(data);
  };

  FormerJS.clear = function (nod, options) {
    return new FormerJS(nod, options).clear();
  };

  FormerJS.prototype.parse = function () {
    return this._process_name_values(this._collect_name_values());
  };

  FormerJS.prototype.fill = function (data) {
    this._traverse_input_nodes(
      this.nod,
      function (nod) {
        this._fill_nod(nod, data);
      }.bind(this)
    );
  };

  FormerJS.prototype.clear = function () {
    this._traverse_input_nodes(
      this.nod,
      function (nod) {
        this._clear_nod(nod);
      }.bind(this)
    );
  };

  FormerJS.prototype._process_name_values = function (name_values) {
    var _result = {};
    var _arrays = {};

    for (var i = 0; i < name_values.length; i++) {
      (function (item) {
        var name = item.name;
        var value = item.value;
        if (this.options.skip_empty && (value === "" || value === null)) return;

        var _arr_fullname = "";
        var _current = _result;

        if (this.options.name_transform) {
          name = this.options.name_transform(name);
        }

        if (this.options.parse_value) {
          value = this.options.parse_value(value);
        }

        var _name_parts = name.split(".");
        var len = _name_parts.length;

        for (var i = 0; i < len; i++) {
          (function (name_part) {
            if (name_part.indexOf("[]") > -1) {
              var _arr_name = name_part.substr(0, name_part.indexOf("["));
              _arr_fullname += _arr_name;

              _current[_arr_name] = _current[_arr_name] || [];

              if (i === len - 1) {
                _current[_arr_name].push(value);
              } else {
                var _next_field = _name_parts[i + 1];
                _arrays[_arr_fullname] = _arrays[_arr_fullname] || [];

                var _arr_len = _arrays[_arr_fullname].length;

                if (_current[_arr_name].length > 0) {
                  var _array_item =
                    _current[_arr_name][_current[_arr_name].length - 1];
                }

                if (
                  !_arr_len ||
                  (_next_field in _arrays[_arr_fullname] &&
                    !(
                      _next_field.indexOf("[]") > -1 ||
                      !(_array_item[_next_field] && i + 1 === len - 1)
                    ))
                ) {
                  _array_item = {};
                  _current[_arr_name].push(_array_item);
                  _arrays[_arr_fullname] = [];
                }

                _arrays[_arr_fullname].push(_next_field);
                _current = _array_item;
              }
            } else {
              _arr_fullname += name_part;

              if (i < len - 1) {
                _current[name_part] = _current[name_part] || {};
                _current = _current[name_part];
              } else {
                _current[name_part] = value;
              }
            }
          })(_name_parts[i]);
        }
      }).call(this, name_values[i]);
    }

    return _result;
  };

  FormerJS.prototype._collect_name_values = function () {
    var result = [];
    this._traverse_input_nodes(
      this.nod,
      function (nod) {
        var parsed_nod = this._parse_nod(nod);
        if (parsed_nod) result.push(parsed_nod);
      }.bind(this)
    );
    return result;
  };

  FormerJS.prototype._traverse_input_nodes = function (nod, callback) {
    var result = this._to_array(callback(nod));
    var current = nod.firstChild;

    while (current) {
      result = result.concat(this._traverse_input_nodes(current, callback));
      current = current.nextSibling;
    }

    return result;
  };

  FormerJS.prototype._to_array = function (val) {
    if (!val) return [];
    if (Array.isArray(val)) return val;
    return [val];
  };

  FormerJS.prototype._parse_nod = function (nod) {
    if (this.options.disabled === false && nod.disabled) return;
    if (!/(input|select|textarea)/i.test(nod.nodeName)) return;
    if (!nod.name) return;

    var val = this._parse_nod_value(nod);
    if (!val) return;

    return {
      name: nod.name,
      value: val,
    };
  };

  FormerJS.prototype._fill_nod = function (nod, data) {
    if (!/(input|select|textarea)/i.test(nod.nodeName)) return;

    var value = this._nod_data_value(nod.name, data);
    if (!value) return;

    if (nod.nodeName.toLowerCase() === "select") {
      this._fill_select(nod, value);
    } else {
      if (typeof value === "object") return;
      var type = nod.type.toLowerCase();
      if (/radio|checkbox/.test(type) && value) nod.checked = true;
      else if (/radio|checkbox/.test(type) && !value) nod.checked = false;
      else nod.value = value;
    }
  };

  FormerJS.prototype._fill_select = function (nod, value) {
    value = Array.isArray(value) ? value : [value];
    var options = nod.getElementsByTagName("option");
    for (var i = 0; i < options.length; i++) {
      (function (option) {
        option.selected = value.indexOf(option.value) > -1;
      })(options[i]);
    }
  };

  FormerJS.prototype._clear_nod = function (nod) {
    if (!/(input|select|textarea)/i.test(nod.nodeName)) return;

    if (nod.nodeName.toLowerCase() === "select") {
      this._fill_select(nod, []);
    } else {
      var type = nod.type.toLowerCase();
      if (/radio|checkbox/.test(type)) nod.checked = false;
      else if (/button|reset|submit|image/.test(type)) return true;
      else if (type === "hidden" && !this.options.clear_hidden) return true;
      else nod.value = "";
    }
  };

  FormerJS.prototype._nod_data_value = function (name, data) {
    if (this.options.fill_prefix) {
      name = name.replace(this.options.fill_prefix, "");
    }
    if (this.options.name_transform) {
      name = this.options.name_transform(name);
    }

    if (name.indexOf("[]") > -1) return;

    var keys = name.split(".");
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      data = data[key];
      if (!data) break;
    }

    return data;
  };

  FormerJS.prototype._parse_nod_value = function (nod) {
    if (nod.nodeName.toLowerCase() === "select") {
      return this._parse_select_value(nod);
    } else {
      var type = nod.type.toLowerCase();
      if (/radio|checkbox/.test(type) && nod.checked) return nod.value;
      else if (/radio|checkbox/.test(type) && !nod.checked) return null;
      else if (/button|reset|submit|image/.test(type)) return null;
      else if (/file/.test(type)) return this._parse_file_value(nod);
      else return nod.value;
    }
  };

  FormerJS.prototype._parse_file_value = function (nod) {
    if (!nod.files.length) return;

    if (nod.multiple) {
      return nod.files;
    } else {
      return nod.files[0];
    }
  };

  FormerJS.prototype._parse_select_value = function (nod) {
    var multiple = nod.multiple;
    if (!multiple) return nod.value;
    var values = [];
    var options = nod.getElementsByTagName("option");
    for (var i = 0; i < options.length; i++) {
      (function (option) {
        if (option.selected) values.push(option.value);
      })(options[i]);
    }
    return values;
  };

  FormerJS.prototype._rails_name_transform = function (name) {
    return name.replace(/\[([^\]])/gi, ".$1").replace(/([^\[])([\]]+)/gi, "$1");
  };

  FormerJS.prototype._serialize = function (val) {
    if (val === null || val === "") return null;
    if (val === "true") return true;
    if (val === "false") return false;
    if (isNaN(Number(val))) return val;
    return Number(val);
  };

  if (typeof define === "function" && define.amd) {
    define(function () {
      return FormerJS;
    });
  } else if (typeof module === "object" && module.exports) {
    module.exports = FormerJS;
  } else {
    window.FormerJS = FormerJS;
  }
})();
